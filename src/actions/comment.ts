/**
 * PR comment utilities for GitHub Action
 * @module actions/comment
 */

import * as github from '@actions/github';
import { ArchitectureAnalysis } from '../types';
import { GeneratorResult } from '../generators';

type Octokit = ReturnType<typeof github.getOctokit>;
type Context = typeof github.context;

const COMMENT_MARKER = '<!-- archpulse-diagram -->';

/**
 * Format analysis results as a PR comment
 */
export function formatAnalysisComment(
  analysis: ArchitectureAnalysis,
  result: GeneratorResult,
  hasChanges: boolean
): string {
  const lines: string[] = [COMMENT_MARKER, '## üèóÔ∏è ArchPulse - Architecture Diagram', ''];

  // Status badge
  if (hasChanges) {
    lines.push('> üîÑ **Architecture changed** in this PR');
  } else {
    lines.push('> ‚úÖ **No architecture changes** detected');
  }
  lines.push('');

  // Summary table
  lines.push('### üìä Analysis Summary');
  lines.push('');
  lines.push('| Metric | Value |');
  lines.push('|--------|-------|');
  lines.push(`| Files Analyzed | ${analysis.filesAnalyzed} |`);
  lines.push(`| Dependencies | ${analysis.totalDependencies} |`);
  lines.push(`| Layers | ${analysis.layers.length} |`);
  lines.push(`| Circular Dependencies | ${analysis.metrics.circularDependencyCount} |`);
  lines.push('');

  // Layers breakdown
  if (analysis.layers.length > 0) {
    lines.push('### üìÅ Detected Layers');
    lines.push('');
    for (const layer of analysis.layers) {
      lines.push(`- **${layer.name}**: ${layer.modules.length} modules`);
    }
    lines.push('');
  }

  // Warnings
  if (analysis.metrics.circularDependencyCount > 0) {
    lines.push('### ‚ö†Ô∏è Warnings');
    lines.push('');
    lines.push(`- Found **${analysis.metrics.circularDependencyCount}** circular dependencies`);
    lines.push('');
  }

  // Generated files
  lines.push('### üìÑ Generated Files');
  lines.push('');
  for (const file of result.files) {
    lines.push(`- \`${file}\``);
  }
  lines.push('');

  // Footer
  lines.push('---');
  lines.push('*Generated by [ArchPulse](https://github.com/ThanhNguyxn/ArchPulse)*');

  return lines.join('\n');
}

/**
 * Find existing ArchPulse comment on a PR
 */
async function findExistingComment(octokit: Octokit, context: Context): Promise<number | null> {
  const { owner, repo } = context.repo;
  const pullNumber = context.payload.pull_request?.number;

  if (!pullNumber) return null;

  const { data: comments } = await octokit.rest.issues.listComments({
    owner,
    repo,
    issue_number: pullNumber,
    per_page: 100,
  });

  const existingComment = comments.find(comment => comment.body?.includes(COMMENT_MARKER));

  return existingComment?.id || null;
}

/**
 * Post or update PR comment with diagram summary
 */
export async function postOrUpdateComment(
  octokit: Octokit,
  context: Context,
  body: string
): Promise<void> {
  const { owner, repo } = context.repo;
  const pullNumber = context.payload.pull_request?.number;

  if (!pullNumber) {
    return;
  }

  const existingCommentId = await findExistingComment(octokit, context);

  if (existingCommentId) {
    // Update existing comment
    await octokit.rest.issues.updateComment({
      owner,
      repo,
      comment_id: existingCommentId,
      body,
    });
  } else {
    // Create new comment
    await octokit.rest.issues.createComment({
      owner,
      repo,
      issue_number: pullNumber,
      body,
    });
  }
}
